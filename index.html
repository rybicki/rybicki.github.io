<!DOCTYPE html><html lang=en><head><title>Joel Rybicki</title><meta charset=UTF-8><meta name=viewport content="width=device-width, initial-scale=1"><link rel=stylesheet href=./w3.css><link rel=stylesheet href=./style.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=academicons-1.8.0/css/academicons.css><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script></head><body class=w3-light-grey><header class="page-header w3-container w3-green w3-center w3-margin-bottom"></header><div class="w3-content w3-margin-top" style=max-width:1400px;> <div class=w3-row-padding> <div class="w3-quarter w3-padding-bottom"><div class="w3-white w3-text-grey w3-card-4"><div class=w3-display-container> <img src=joel.jpg style=width:100% alt=Joel></div><div class=w3-container> <h2 title="/ˈjoel rɨˈbit͡s.ki/">Prof. Dr. Joel Rybicki</h2> <p><b><a href=https://hu.berlin/disco>Chair of Distributed Computing</a></b><br> <a href=https://www.hu-berlin.de> Humboldt University of Berlin</a> <br> <a href=https://www.informatik.hu-berlin.de/en> Department of Computer Science</a> </p> <hr> <p><i class="fa fa-envelope fa-fw w3-margin-right w3-large w3-text-green"></i>firstname.lastname at hu-berlin dot de <br> <p><i class="ai ai-orcid fa-fw w3-margin-right w3-large w3-text-green"></i><a href=https://orcid.org/0000-0002-6432-6646 target=orcid.widget rel="noopener noreferrer" style=vertical-align:top;word-wrap:break-word;>orcid.org/<wbr>0000-0002-6432-6646</a> <p><i class="ai ai-google-scholar-square fa-fw w3-margin-right w3-large w3-text-green"></i><a href="https://scholar.google.fi/citations?user=IlMcwsEAAAAJ">Google Scholar</a></p> <hr> <p><i class="fa fa-home fa-fw w3-margin-right w3-large w3-text-green"></i> <b>Office</b> <p><a href=https://goo.gl/maps/UoV4nMecfowJ87NL9> Johann-von-Neumann-Haus</a> <br> Room IV.014 <br> </p> <hr> <p><i class="fa fa-university fa-fw w3-margin-right w3-large w3-text-green"></i> <b>Postal address </b></p> <p>Humboldt-Universit&auml;t zu Berlin <br> Institut f&uuml;r Informatik <br> Unter den Linden 6 <br> 10099 Berlin <br> </p> </div></div> </div> <div class=w3-threequarter> <div class="w3-container w3-card w3-white w3-margin-bottom"> <h2 class=w3-text-grey>Research</h2><div class=w3-container> <p>I am a junior professor (&asymp; assistant professor) of <a href=https://en.wikipedia.org/wiki/Distributed_computing> distributed computing </a> at Humboldt University of Berlin.</p> <p>My research focuses on <a href=https://en.wikipedia.org/wiki/Theoretical_computer_science> theoretical foundations</a> of distributed computing. I also occasionally work in the area of <a href=https://en.wikipedia.org/wiki/Theoretical_ecology>theoretical ecology</a>, mainly using stochastic models to study the dynamics of large-scale ecological communities.</p><ul class=intlist><li class=li-int><span class="papertitle w3-opacity w3-large">Theoretical computer science:</span><br>distributed algorithms, graph algorithms, fault-tolerant coordination and synchronisation, stochastic interaction models </li><li class=li-int><span class="papertitle w3-opacity w3-large">Theoretical ecology:</span><br> stochastic spatial models, community dynamics, habitat loss and fragmentation, individual-based modelling</li></ul></div> <hr> <h2 class=w3-text-grey>News</h2> <div class=w3-container> <ul class=newslist> <li class=li-news><span class="papertitle w3-opacity w3-large">January 2024 </span><br>There is an open postdoc/PhD position in my group for two years. See <a href=https://www.informatik.hu-berlin.de/de/forschung/gebiete/disco/open-positions>here for further information</a>. </li> </ul> </div> <hr> <h2 class=w3-text-grey>Short bio</h2><div class=w3-container> <ul class=biolist> <li class=li-bio><span class="papertitle w3-opacity w3-large">2023&ndash;: Junior professor of Distributed Computing (HU Berlin) </span><br> Junior professor (tenure track) at Humboldt University of Berlin </li> <li class=li-bio><span class="papertitle w3-opacity w3-large">2018&ndash;2022: Postdoc (IST Austria) </span><br> Postdoctoral researcher at Institute of Science and Technology Austria (IST Austria). Funded by: <ul> <li><a href=https://istplus.pages.ist.ac.at/ >ISTplus fellowship</a> 2018&ndash;2019</li> <li><a href=https://ec.europa.eu/research/mariecurieactions/actions/individual-fellowships_en>Marie Sk&#322;odowska-Curie Actions Individual Fellowship</a> 2019--2021</li> </ul> </li><li class=li-bio><span class="papertitle w3-opacity w3-large">2016&ndash;2017: Postdoc (University of Helsinki) </span><br> Postdoctoral researcher at the <a href=https://www.helsinki.fi/en/researchgroups/metapopulation-research-centre/research-and-subgroups/mathematical-biology-group>Mathematical biology group</a></li><li class=li-bio><span class="papertitle w3-opacity w3-large">2012&ndash;2016: Doctoral student (University of Helsinki and Aalto University)</span><br> Doctoral student at the <a href=http://research.cs.aalto.fi/da/ >Distributed algorithms group</a></li></li><li class=li-bio><span class="papertitle w3-opacity w3-large">2014&ndash;2015: Guest researcher (Max Planck Institute for Informatics)</span><br> Guest researcher at the Theory of distributed systems and embedded systems group</li><li class=li-bio><span class="papertitle w3-opacity w3-large">2011&ndash;2012: Researcher (University of Helsinki)</span><br> Researcher in <a href=https://www.helsinki.fi/en/researchgroups/metapopulation-research-centre/ >Metapopulation research group</a></li></ul></div> <div class=w3-container> <p><b class=w3-text-grey>PC memberships: </b> <a href=https://www.disc-conference.org/wp/disc2024/ >DISC 2024</a> • <a href=http://sirocco2024.di.unisa.it/ >SIROCCO 2024</a> • <a href=https://icdcs2021.us/ > ICDCS 2021</a> • <a href=https://infocom2017.ieee-infocom.org/workshop/netscicom-network-science-communication-network.html>NetSciCom 2017</a>.</p> </div> <hr> <h2 class="w3-text-grey w3">Publications</h2><script>
function myFunction(id) {
    var x = document.getElementById(id+"-full");
    var y = document.getElementById(id);
    if (x.className.indexOf("w3-show") == -1) {
        x.className += " w3-show";
        y.className = "li-pub-open";
    } else {
        x.className = x.className.replace(" w3-show", "");
        y.className = "li-pub-closed";
    }
}
</script><div class=w3-container><h3 class=w3-opacity>2024</h3><ul class=publist><li id=fuegger2024majority class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('fuegger2024majority')">Majority consensus thresholds for competitive Lotka--Volterra populations</a><br> <a href=http://www.lsv.fr/~mfuegger/ class=authorurl>Matthias Függer</a>, <a href=https://www.lri.fr/~nowak/ class=authorurl>Thomas Nowak</a> and <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> &bull; <i> <a href=https://www.podc.org/podc2024/ class=authorurl> PODC 2024 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://arxiv.org/abs/2405.03568>arXiv preprint</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=fuegger2024majority-full> <p> ACM Symposium on Principles of Distributed Computing (2024) </p> <hr> <h6>Abstract</h6> <p>One of the key challenges in synthetic biology is devising robust signaling primitives for engineered microbial consortia. In such systems, a fundamental signal amplification problem is the majority consensus problem: given a system with two input species with initial difference of $\Delta$ in population sizes, what is the probability that the system reaches a state in which only the initial majority species is present?</p><p>In this work, we consider a discrete and stochastic version of competitive Lotka--Volterra dynamics, a standard model of microbial community dynamics. We identify new threshold properties for majority consensus under different types of interference competition:<ul><li>We show that under so-called self-destructive interference competition between the two input species, majority consensus can be reached with high probability if the initial difference satisfies $\Delta \in \Omega(\log^2 n)$, where $n$ is the initial population size. This gives an exponential improvement compared to the previously known bound of $\Omega(n \log n)$ by Cho et al. [Distributed Computing, 2021] given for a special case of the competitive Lotka--Volterra model. In contrast, we show that an initial gap of $\Delta \in \Omega(\sqrt{\log n})$ is necessary. <li>On the other hand, we show that under non-self-destructive interference competition, an initial gap of $\Omega(\sqrt{n})$ is necessary to succeed with high probability and that a $\Omega(\sqrt{n \log n})$ gap is sufficient. </li></ul>This shows a strong qualitative gap between the performance of self-destructive and non-self-destructive interference competition. Moreover, we show that if in addition the populations exhibit interference competition between the individuals of the same species, then majority consensus cannot always be solved with high probability, no matter what the difference in the initial population counts.</p> </div> </li></ul><h3 class=w3-opacity>2023</h3><ul class=publist><li id=alistarh2023waitfree class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('alistarh2023waitfree')">Wait-free approximate agreement on graphs</a><br> <a href=https://people.csail.mit.edu/alistarh/ class=authorurl>Dan Alistarh</a>, <a href=https://www.cs.toronto.edu/~faith/ class=authorurl>Faith Ellen</a> and <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> &bull; <i> <a class=authorurl href=https://www.sciencedirect.com/journal/theoretical-computer-science> Theoretical Computer Science 2023 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1016/j.tcs.2023.113733>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=#alistarh21wait-free>Conference version</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=alistarh2023waitfree-full> <p> Theoretical Computer Science, volume 948, number 113733 (2023) &bull; <a href=http://dx.doi.org/10.1016/j.tcs.2023.113733>doi:10.1016/j.tcs.2023.113733</a> </p> <hr> <h6>Abstract</h6> <p>Approximate agreement is one of the few variants of consensus that can be solved in a wait-free manner in asynchronous systems where processes communicate by reading and writing to shared memory. In this work, we consider a natural generalisation of approximate agreement on arbitrary undirected connected graphs. Each process is given a node of the graph as input and, if non-faulty, must output a node such that <ul> <li>all the outputs are within distance 1 of one another, and</li><li>each output value lies on a shortest path between two input values.</li> </ul> From prior work, it is known that there is no wait-free algorithm among n ≥ 3 processes for this problem on any cycle of length c ≥ 4, by reduction from 2-set agreement (Castañeda et al., 2018).</p> <p>In this work, we investigate the solvability of this task on general graphs. We give a new, direct proof of the impossibility of approximate agreement on cycles of length c ≥ 4, via a generalisation of Sperner’s Lemma to convex polygons. We also extend the reduction from 2-set agreement to a larger class of graphs, showing that approximate agreement on these graphs is unsolvable. On the positive side, we present a wait-free algorithm for a different class of graphs, which properly contains the class of chordal graphs.</p> </div> </li><li id=balliu2022sinkless class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('balliu2022sinkless')">Sinkless Orientation Made Simple</a><br> <a href=https://alkida.net/ class=authorurl>Alkida Balliu</a>, <a href=https://pub.ist.ac.at/~jkorhone/ class=authorurl>Janne H. Korhonen</a>, Fabian Kuhn, Henrik Lievonen, <a href=http://ac.informatik.uni-freiburg.de/olivetti/ class=authorurl>Dennis Olivetti</a>, Shreyas Pai, <a href=https://sites.google.com/view/amipaz/ class=authorurl>Ami Paz</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a>, <a href=https://schmiste.github.io/ class=authorurl>Stefan Schmid</a>, Jan Studený, <a href=http://users.ics.aalto.fi/suomela/ class=authorurl>Jukka Suomela</a> and <a href=https://users.aalto.fi/~uittoj3/ class=authorurl>Jara Uitto</a> &bull; <i> <a class=authorurl href=https://www.siam.org/conferences/cm/conference/sosa23> SOSA 2023 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1137/1.9781611977585.ch17>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/2108.02655>arXiv preprint</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=balliu2022sinkless-full> <p> SIAM Symposium on Simplicity in Algorithms (2023) &bull; <a href=http://dx.doi.org/10.1137/1.9781611977585.ch17>doi:10.1137/1.9781611977585.ch17</a> </p> <hr> <h6>Abstract</h6> <p>The sinkless orientation problem plays a key role in understanding the foundations of distributed computing. The problem can be used to separate two fundamental models of distributed graph algorithms, LOCAL and SLOCAL: the locality of sinkless orientation is $\Omega(\log n)$ in the deterministic LOCAL model and $O(\log \log n)$ in the deterministic SLOCAL model. Both of these results are known by prior work, but here we give new simple, self-contained proofs for them.</p> </div> </li></ul><h3 class=w3-opacity>2022</h3><ul class=publist><li id=alistarh22le class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('alistarh22le')">Near-Optimal Leader Election in Population Protocols on Graphs</a><br> <a href=https://people.csail.mit.edu/alistarh/ class=authorurl>Dan Alistarh</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> and Sasha Voitovych &bull; <i> <a class=authorurl href=https://www.podc.org/podc2022> PODC 2022 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1145/3519270.3538435>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/2205.12597>arXiv preprint</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=alistarh22le-full> <p> 41st ACM Symposium on Principles of Distributed Computing (2022) &bull; <a href=http://dx.doi.org/10.1145/3519270.3538435>doi:10.1145/3519270.3538435</a> </p> <hr> <h6>Abstract</h6> <p>In the <i>stochastic population protocol</i> model, we are given a connected graph with $n$ nodes, and in every time step, a scheduler samples an edge of the graph uniformly at random and the nodes connected by this edge interact. A fundamental task in this model is <i>stable leader election</i>, in which all nodes start in an identical state and the aim is to reach a configuration in which (1) exactly one node is elected as leader and (2) this node remains as the unique leader no matter what sequence of interactions follows. On <i>cliques</i>, the complexity of this problem has recently been settled: time-optimal protocols stabilize in $\Theta(n \log n)$ expected steps using $\Theta(\log \log n)$ states, whereas protocols that use $O(1)$ states require $\Theta(n^2)$ expected steps.</p><p>In this work, we investigate the complexity of stable leader election on general graphs. We provide the first non-trivial time lower bounds for leader election on general graphs, showing that, when moving beyond cliques, the complexity landscape of leader election becomes very diverse: the time required to elect a leader can range from $O(1)$ to $\Theta(n^3)$ expected steps. On the upper bound side, we first observe that there exists a protocol that is time-optimal on many graph families, but uses polynomially-many states. In contrast, we give a near-time-optimal protocol that uses only $O(\log^2n)$ states that is at most a factor $\log n$ slower. Finally, we show that the constant-state protocol of Beauquier et al. [OPODIS 2013] is at most a factor $n \log n$ slower than the fast polynomial-state protocol. Moreover, among constant-state protocols, this protocol has near-optimal <i>average case complexity</i> on dense random graphs.</p> </div> </li><li id=pacut2021locality class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('pacut2021locality')">Brief Annoucement: Locality in online algorithms</a><br> <a href=https://maciejpacut.github.io/ class=authorurl>Maciej Pacut</a>, Mahmoud Parham, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a>, <a href=https://schmiste.github.io/ class=authorurl>Stefan Schmid</a>, <a href=http://users.ics.aalto.fi/suomela/ class=authorurl>Jukka Suomela</a> and Aleksandr Tereshchenko &bull; <i> DISC 2022 </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://arxiv.org/abs/2102.09413>arXiv preprint</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=pacut2021locality-full> <p> 36th International Symposium on Distributed Computing (2022) </p> <hr> <h6>Abstract</h6> <p>Online algorithms make decisions based on past inputs. In general, the decision may depend on the entire history of inputs. If many computers run the same online algorithm with the same input stream but are started at different times, they do not necessarily make consistent decisions.</p><p>In this work we introduce <i>time-local online algorithms</i>. These are online algorithms where the output at a given time only depends on $T = O(1)$ latest inputs. The use of (deterministic) time-local algorithms in a distributed setting automatically leads to globally consistent decisions.</p><p>Our key observation is that time-local online algorithms (in which the output at a given time only depends on local inputs in the temporal dimension) are closely connected to <i>local distributed graph algorithms</i> (in which the output of a given node only depends on local inputs in the spatial dimension). This makes it possible to interpret prior work on distributed graph algorithms from the perspective of online algorithms.</p><p>We describe an <i>algorithm synthesis method</i> that one can use to design optimal time-local online algorithms for small values of $T$. We demonstrate the power of the technique in the context of a variant of the <i>online file migration problem</i>, and show that e.g. for two nodes and unit migration costs there exists a $3$-competitive time-local algorithm with horizon $T=4$, while no deterministic online algorithm (in the classic sense) can do better. We also derive upper and lower bounds for a more general version of the problem; we show that there is a $6$-competitive deterministic time-local algorithm and a $2.62$-competitive randomized time-local algorithm for any migration cost $\alpha \ge 1$.</p> </div> </li><li id=balliu2021mending class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('balliu2021mending')">Local mending</a><br> <a href=https://alkida.net/ class=authorurl>Alkida Balliu</a>, <a href=https://users.aalto.fi/~hirvonj7/ class=authorurl>Juho Hirvonen</a>, Darya Melnyk, <a href=http://ac.informatik.uni-freiburg.de/olivetti/ class=authorurl>Dennis Olivetti</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> and <a href=http://users.ics.aalto.fi/suomela/ class=authorurl>Jukka Suomela</a> &bull; <i> SIROCCO 2022 </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1007/978-3-031-09993-9_1>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/2102.08703>arXiv preprint</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=balliu2021mending-full> <p> 29th International Colloquium on Structural Information and Communication Complexity (2022) &bull; <a href=http://dx.doi.org/10.1007/978-3-031-09993-9_1>doi:10.1007/978-3-031-09993-9_1</a> </p> <hr> <h6>Abstract</h6> <p>In this work we introduce the graph-theoretic notion of <i>mendability</i>: for each locally checkable graph problem we can define its <i>mending radius</i>, which captures the idea of how far one needs to modify a partial solution in order to ``patch a hole.''</p><p>We explore how mendability is connected to the existence of efficient algorithms, especially in distributed, parallel, and fault-tolerant settings. It is easy to see that $O(1)$-mendable problems are also solvable in $O(\log^* n)$ rounds in the LOCAL model of distributed computing. One of the surprises is that in paths and cycles, a converse also holds in the following sense: if a problem $\Pi$ can be solved in $O(\log^* n)$, there is always a restriction $\Pi' \subseteq \Pi$ that is still efficiently solvable but that is also $O(1)$-mendable.</p><p>We also explore the structure of the landscape of mendability. For example, we show that in trees, the mending radius of any locally checkable problem is $O(1)$, $\Theta(\log n)$, or $\Theta(n)$, while in general graphs the structure is much more diverse.</p> </div> </li></ul><h3 class=w3-opacity>2021</h3><ul class=publist><li id=alistarh21wait-free class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('alistarh21wait-free')">Wait-free approximate agreement on graphs</a><br> <a href=https://people.csail.mit.edu/alistarh/ class=authorurl>Dan Alistarh</a>, <a href=https://www.cs.toronto.edu/~faith/ class=authorurl>Faith Ellen</a> and <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> &bull; <i> <a href=https://sirocco2021.ii.uni.wroc.pl/ class=authorurl> SIROCCO 2021 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1007/978-3-030-79527-6_6>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/2103.08949>arXiv preprint</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=alistarh21wait-free-full> <p> 28th International Colloquium on Structural Information and Communication Complexity (2021) &bull; <a href=http://dx.doi.org/10.1007/978-3-030-79527-6_6>doi:10.1007/978-3-030-79527-6_6</a> </p> <hr> <h6>Abstract</h6> <p>Approximate agreement is one of the few variants of consensus that can be solved in a wait-free manner in asynchronous systems where processes communicate by reading and writing to shared memory. In this work, we consider a natural generalisation of approximate agreement on arbitrary undirected connected graphs. Each process is given a vertex of the graph as input and, if non-faulty, must output a vertex such that<ul><li>all the outputs are within distance 1 of one another, and</li><li>each output value lies on a shortest path between two input values.</li></ul></p><p>From prior work, it is known that there is no wait-free algorithm among $n \ge 3$ processes for this problem on any cycle of length $c \ge 4$, by reduction from 2-set agreement (Castañeda et al., 2018).</p><p>In this work, we investigate the solvability and complexity of this task on general graphs. We give a new, direct proof of the impossibility of approximate agreement on cycles of length $c \ge 4$, via a generalisation of Sperner's Lemma to convex polygons. We also extend the reduction from 2-set agreement to a larger class of graphs, showing that approximate agreement on on these graphs is unsolvable. Furthermore, we show that combinatorial arguments, used by both existing proofs, are necessary, by showing that the impossibility of a wait-free algorithm in the nonuniform iterated snapshot model cannot be proved via an extension-based proof. On the positive side, we present a wait-free algorithm for a class of graphs that properly contains the class of chordal graphs.</p> </div> </li><li id=brandt2020efficient class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('brandt2020efficient')">Efficient load-balancing through distributed token dropping</a><br> <a class=authorurl href=http://www.disco.ethz.ch/members/brandts.html>Sebastian Brandt</a>, <a href=https://users.aalto.fi/~kellerb1/ class=authorurl>Barbara Keller</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a>, <a href=http://users.ics.aalto.fi/suomela/ class=authorurl>Jukka Suomela</a> and <a href=https://users.aalto.fi/~uittoj3/ class=authorurl>Jara Uitto</a> &bull; <i> <a href=https://spaa.acm.org/ class=authorurl> SPAA 2021 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1145/3409964.3461785>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/2005.07761>arXiv preprint</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=brandt2020efficient-full> <p> 33th ACM Symposium on Parallelism in Algorithms and Architectures (2021) &bull; <a href=http://dx.doi.org/10.1145/3409964.3461785>doi:10.1145/3409964.3461785</a> </p> <hr> <h6>Abstract</h6> <p>We introduce a new graph problem, the token dropping game, and we show how to solve it efficiently in a distributed setting. We use the token dropping game as a tool to design an efficient distributed algorithm for stable orientations and more generally for locally optimal semi-matchings. The prior work by Czygrinow et al. (DISC 2012) finds a stable orientation in $O(\Delta^5)$ rounds in graphs of maximum degree $\Delta$, while we improve it to $O(\Delta^4)$ and also prove a lower bound of $\Omega(\Delta)$. For the more generalproblem of locally optimal semi-matchings, the prior upper bound is $O(S^5)$ and our new algorithm runs in $O(C \cdot S^4)$ rounds, which is an improvement for $C=o(S)$; here $C$ and $S$ are the maximum degrees of customers and servers, respectively.</p> </div> </li><li id=korhonen2021sinkless class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('korhonen2021sinkless')">Brief announcement: Sinkless orientation is hard also in the supported LOCAL model</a><br> <a href=https://pub.ist.ac.at/~jkorhone/ class=authorurl>Janne H. Korhonen</a>, <a href=https://sites.google.com/view/amipaz/ class=authorurl>Ami Paz</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a>, <a href=https://schmiste.github.io/ class=authorurl>Stefan Schmid</a> and <a href=http://users.ics.aalto.fi/suomela/ class=authorurl>Jukka Suomela</a> &bull; <i> DISC 2021 </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.4230/LIPIcs.DISC.2021.58>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/2108.02655>arXiv preprint</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=korhonen2021sinkless-full> <p> 35th International Symposium on Distributed Computing (2021) &bull; <a href=http://dx.doi.org/10.4230/LIPIcs.DISC.2021.58>doi:10.4230/LIPIcs.DISC.2021.58</a> </p> <hr> <h6>Abstract</h6> <p>We show that any algorithm that solves the sinkless orientation problem in the supported LOCAL model requires $\Omega(\log n)$ rounds, and this is tight. The supported LOCAL is at least as strong as the usual LOCAL model, and as a corollary this also gives a new, short and elementary proof that shows that the round complexity of the sinkless orientation problem in the deterministic LOCAL model is $\Omega(\log n)$.</p> </div> </li><li id=alistarh2021graphical class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('alistarh2021graphical')">Fast graphical population protocols</a><br> <a href=https://people.csail.mit.edu/alistarh/ class=authorurl>Dan Alistarh</a>, Rati Gelashvili and <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> &bull; <i> OPODIS 2021 </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.4230/LIPIcs.OPODIS.2021.14>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/2102.08808>arXiv preprint</a></li> <li class=list-inline-item><a href=https://doi.org/10.4230/LIPIcs.DISC.2021.58>DISC BA</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=alistarh2021graphical-full> <p> Conference on Principles of Distributed Systems (2021) &bull; <a href=http://dx.doi.org/10.4230/LIPIcs.OPODIS.2021.14>doi:10.4230/LIPIcs.OPODIS.2021.14</a> </p> <hr> <h6>Abstract</h6> <p>Let $G$ be a graph on $n$ nodes. In the stochastic population protocol model, a collection of $n$ indistinguishable, resource-limited nodes collectively solve tasks via pairwise interactions. In each interaction, two randomly chosen neighbours first read each other's states, and then update their local states. A rich line of research has established tight upper and lower bounds on the complexity of fundamental tasks, such as majority and leader election, in this model, when $G$ is a <i>clique</i>. Specifically, in the clique, these tasks can be solved <i>fast</i>, i.e., in $n \operatorname{polylog} n$ pairwise interactions, with high probability, using at most $\operatorname{polylog} n$ states per node.</p><p> In this work, we consider the more general setting where $G$ is an arbitrary graph, and present a technique for simulating protocols designed for fully-connected networks in any connected regular graph. Our main result is a simulation that is <i>efficient</i> on many interesting graph families: roughly, the simulation overhead is polylogarithmic in the number of nodes, and quadratic in the conductance of the graph. As a sample application, we show that, in any regular graph with conductance $\phi$, both leader election and exact majority can be solved in $\phi^{-2} \cdot n \operatorname{polylog} n$ pairwise interactions, with high probability, using at most $\phi^{-2} \cdot \operatorname{polylog} n$ states per node. This shows that there are fast and space-efficient population protocols for leader election and exact majority on graphs with good expansion properties. We believe our results will prove generally useful, as they allow efficient technology transfer between the well-mixed (clique) case, and the under-explored spatial setting.</p></p> </div> </li><li id=foerster2020input class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('foerster2020input')">Input-dynamic distributed graph algorithms for communication networks</a><br> <a href=https://ktfoerster.github.io/ class=authorurl>Klaus-Tycho Foerster</a>, <a href=https://pub.ist.ac.at/~jkorhone/ class=authorurl>Janne H. Korhonen</a>, <a href=https://sites.google.com/view/amipaz/ class=authorurl>Ami Paz</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> and <a href=https://schmiste.github.io/ class=authorurl>Stefan Schmid</a> &bull; <i> <a class=authorurl href=https://dl.acm.org/journal/pomacs> Proceedings of the ACM on Measurement and Analysis of Computing Systems 2021 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1145/3447384>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/2005.07637>arXiv preprint</a></li> <li class=list-inline-item><a href=https://www.sigmetrics.org/sigmetrics2021/ >SIGMETRICS 2021</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=foerster2020input-full> <p> Proceedings of the ACM on Measurement and Analysis of Computing Systems, volume 5, number 1 (2021) &bull; <a href=http://dx.doi.org/10.1145/3447384>doi:10.1145/3447384</a> </p> <hr> <h6>Abstract</h6> <p>Consider a distributed system, where the topology of the communication network remains fixed, but local inputs given to nodes may change over time. In this work, we explore the following question: if some of the local inputs change, can an existing solution be updated efficiently, in a dynamic and distributed manner?</p> <p>To address this question, we define the batch dynamic CONGEST model, where the communication network $G=(V,E)$ remains fixed and a dynamic edge labelling defines the problem input. The task is to maintain a solution to a graph problem on the labeled graph under batch changes. We investigate, when a batch of α edge label changes arrive, <ul> <li>how much time as a function of α we need to update an existing solution, and</li><li>how much information the nodes have to keep in local memory between batches in order to update the solution quickly.</li> </ul></p> <p>We give a general picture of the complexity landscape in this model, including a general framework for lower bounds. In particular, we prove non-trivial upper bounds for two selected, contrasting problems: maintaining a minimum spanning tree and detecting cliques.</p> </div> </li></ul><h3 class=w3-opacity>2020</h3><ul class=publist><li id=rybicki19fragmentation class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('rybicki19fragmentation')">Habitat fragmentation and species diversity in competitive communities</a><br> <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a>, <a href=https://nereaabrego.wordpress.com/ class=authorurl>Nerea Abrego</a> and <a class=authorurl href=http://www.helsinki.fi/science/metapop/People/Otso.htm>Otso Ovaskainen</a> &bull; <i> <a class=authorurl href=https://onlinelibrary.wiley.com/journal/14610248> Ecology Letters 2020 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <i class="ai ai-open-access w3-text-green"></i> <a href=http://dx.doi.org/10.1111/ele.13450>Publisher&#x27;s version</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=rybicki19fragmentation-full> <p> Ecology Letters, volume 23, pages 506--517 (2020) &bull; <a href=http://dx.doi.org/10.1111/ele.13450>doi:10.1111/ele.13450</a> </p> <hr> <h6>Abstract</h6> <p>Habitat loss is one of the key drivers of the ongoing decline of biodiversity. However, ecologists still argue about how fragmentation of habitat (independent of habitat loss) affects species richness. The recently proposed habitat amount hypothesis posits that species richness only depends on the total amount of habitat in a local landscape. On the other hand, different empirical studies report contrasting patterns: some find positive and others negative effects of fragmentation <i>per se</i> on species richness. To explain this apparent disparity, we devise a stochastic, spatially-explicit model of competitive species communities in heterogeneous habitats. The model shows that habitat loss and fragmentation have a non-monotone and non-linear effect on the species diversity in competitive communities. When the total amount of habitat is large, fragmentation <i>per se</i> tends to increase species diversity, but if the total amount of habitat is small, the situation is reversed: fragmentation <i>per se</i> decreases species diversity.</p> </div> </li></ul><h3 class=w3-opacity>2019</h3><ul class=publist><li id=ovaskainen19observational class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('ovaskainen19observational')">What can observational data reveal about metacommunity processes?</a><br> <a class=authorurl href=http://www.helsinki.fi/science/metapop/People/Otso.htm>Otso Ovaskainen</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> and <a href=https://nereaabrego.wordpress.com/ class=authorurl>Nerea Abrego</a> &bull; <i> Ecography 2019 </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <i class="ai ai-open-access w3-text-green"></i> <a href=http://dx.doi.org/10.1111/ecog.04444>Publisher&#x27;s version</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=ovaskainen19observational-full> <p> Ecography, (2019) &bull; <a href=http://dx.doi.org/10.1111/ecog.04444>doi:10.1111/ecog.04444</a> </p> <hr> <h6>Abstract</h6> <p>A key challenge for community ecology is to understand to what extent observational data can be used to infer the underlying community assembly processes. As different processes can lead to similar or even identical patterns, statistical analyses of non-manipulative observational data never yield undisputable causal inference on the underlying processes. Still, most empirical studies in community ecology are based on observational data, and hence understanding under which circumstances such data can shed light on assembly processes is a central concern for community ecologists. We simulated a spatial agent-based model that generates variation in metacommunity dynamics across multiple axes, including the four classic metacommunity paradigms as special cases. We further simulated a virtual ecologist who analysed snapshot data sampled from the simulations using eighteen output metrics derived from beta-diversity and habitat variation indices, variation partitioning and joint species distribution modelling. Our results indicated two main axes of variation in the output metrics. The first axis of variation described whether the landscape has patchy or continuous variation, and thus was essentially independent of the properties of the species community. The second axis of variation related to the level of predictability of the metacommunity. The most predictable communities were niche-based metacommunities inhabiting static landscapes with marked environmental heterogeneity, such as metacommunities following the species sorting paradigm or the mass effects paradigm. The most unpredictable communities were neutral-based metacommunities inhabiting dynamics landscapes with little spatial heterogeneity, such as metacommunities following the neutral or patch sorting paradigms. The output metrics from joint species distribution modelling yielded generally the highest resolution to disentangle among the simulated scenarios. Yet, the different types of statistical approaches utilized in this study carried complementary information, and thus our results suggest that the most comprehensive evaluation of metacommunity structure can be obtained by combining them.</p> </div> </li><li id=lenzen2019pulse class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('lenzen2019pulse')">Self-stabilising Byzantine clock synchronisation is almost as easy as consensus</a><br> <a href=http://people.mpi-inf.mpg.de/~clenzen/ class=authorurl>Christoph Lenzen</a> and <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> &bull; <i> <a href=https://jacm.acm.org/ class=authorurl> Journal of the ACM 2019 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <i class="ai ai-open-access w3-text-green"></i> <a href=http://dx.doi.org/10.1145/3339471>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/1705.06173>arXiv preprint</a></li> <li class=list-inline-item> <a href=#lenzen2017pulse>Conference version</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=lenzen2019pulse-full> <p> Journal of the ACM, volume 66, number 5 (2019) &bull; <a href=http://dx.doi.org/10.1145/3339471>doi:10.1145/3339471</a> </p> <hr> <h6>Abstract</h6> <p>We give fault-tolerant algorithms for establishing synchrony in distributed systems in which each of the $n$ nodes has its own clock. Our algorithms operate in a very strong fault model: we require self-stabilisation, i.e., the initial state of the system may be arbitrary, and there can be up to $f\lt n/3$ ongoing Byzantine faults, i.e., nodes that deviate from the protocol in an arbitrary manner. Furthermore, we assume that the local clocks of the nodes may progress at different speeds (clock drift) and communication has bounded delay. In this model, we study the pulse synchronisation problem, where the task is to guarantee that eventually all correct nodes generate well-separated local pulse events (i.e., unlabelled logical clock ticks) in a synchronised manner. </p><p> Compared to prior work, we achieve <i>exponential</i> improvements in stabilisation time and the number of communicated bits, and give the first sublinear-time algorithm for the problem: <ul> <li> In the deterministic setting, the state-of-the-art solutions stabilise in time $\Theta(f)$ and have each node broadcast $\Theta(f \log f)$ bits per time unit. We exponentially reduce the number of bits broadcasted per time unit to $\Theta(\log f)$ while retaining the same stabilisation time.</li><li>In the randomised setting, the state-of-the-art solutions stabilise in time $\Theta(f)$ and have each node broadcast $O(1)$ bits per time unit. We exponentially reduce the stabilisation time to $\mathrm{polylog} f$ while each node broadcasts $\mathrm{polylog} f$ bits per time unit.</li></ul><p>These results are obtained by means of a recursive approach reducing the above task of <i>self-stabilising</i> pulse synchronisation in the <i>bounded-delay</i> model to <i>non-self-stabilising</i> binary consensus in the <i>synchronous</i> model. In general, our approach introduces at most logarithmic overheads in terms of stabilisation time and broadcasted bits over the underlying consensus routine.</p> </div> </li><li id=nowak19approximate class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('nowak19approximate')">Byzantine approximate agreement on graphs</a><br> <a href=https://www.lri.fr/~nowak/ class=authorurl>Thomas Nowak</a> and <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> &bull; <i> <a href=http://www.disc-conference.org/wp/disc2019/ class=authorurl> DISC 2019 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <i class="ai ai-open-access w3-text-green"></i> <a href=http://dx.doi.org/10.4230/LIPIcs.DISC.2019.29>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/1908.02743>arXiv preprint</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=nowak19approximate-full> <p> 33rd International Symposium on Distributed Computing (2019) &bull; <a href=http://dx.doi.org/10.4230/LIPIcs.DISC.2019.29>doi:10.4230/LIPIcs.DISC.2019.29</a> </p> <hr> <h6>Abstract</h6> <p>Consider a distributed system with $n$ processors out of which $f$ can be Byzantine faulty. In the approximate agreement task, each processor $i$ receives an input value $x_i$ and has to decide on an output value $y_i$ such that <ul><li> the output values are in the convex hull of the non-faulty processors' input values,</li> <li>the output values are within distance $d$ of each other.</li></ul> <br> Classically, the values are assumed to be from an $m$-dimensional Euclidean space, where $m \ge 1$. </p><p>In this work, we study the task in a discrete setting, where input values with some structure expressible as a graph. Namely, the input values are vertices of a finite graph $G$ and the goal is to output vertices that are within distance $d$ of each other in $G$, but still remain in the graph-induced convex hull of the input values. For $d=0$, the task reduces to consensus and cannot be solved with a deterministic algorithm in an asynchronous system even with a single crash fault. For any $d \ge 1$, we show that the task is solvable in asynchronous systems when $G$ is chordal and $n > (\omega+1)f$, where $\omega$ is the clique number of $G$. In addition, we give the first Byzantine-tolerant algorithm for a variant of lattice agreement. For synchronous systems, we show tight resilience bounds for the exact variants of these and related tasks over a large class of combinatorial structures.</p> </div> </li><li id=foerster19preprocessing class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('foerster19preprocessing')">Brief announcement: Does preprocessing help under congestion?</a><br> <a href=https://ktfoerster.github.io/ class=authorurl>Klaus-Tycho Foerster</a>, <a href=https://pub.ist.ac.at/~jkorhone/ class=authorurl>Janne H. Korhonen</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> and <a href=https://schmiste.github.io/ class=authorurl>Stefan Schmid</a> &bull; <i> <a class=authorurl href=https://www.podc.org/podc2019> PODC 2019 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1145/3293611.3331581>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/1905.03012>arXiv preprint</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=foerster19preprocessing-full> <p> 38th ACM Symposium on Principles of Distributed Computing (2019) &bull; <a href=http://dx.doi.org/10.1145/3293611.3331581>doi:10.1145/3293611.3331581</a> </p> <hr> <h6>Abstract</h6> <p>This paper investigates the power of preprocessing in the CONGEST model. Schmid and Suomela (ACM HotSDN 2013) introduced the SUPPORTED CONGEST model to study the application of distributed algorithms in Software-Defined Networks (SDNs). In this paper, we show that a large class of lower bounds in the CONGEST model still hold in the SUPPORTED model, highlighting the robustness of these bounds. This also raises the question how much does preprocessing help in the CONGEST model.</p> </div> </li><li id=lenzen18firing class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('lenzen18firing')">Near-optimal self-stabilising counting and firing squads</a><br> <a href=http://people.mpi-inf.mpg.de/~clenzen/ class=authorurl>Christoph Lenzen</a> and <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> &bull; <i> <a class=authorurl href=https://link.springer.com/journal/446> Distributed Computing 2019 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <i class="ai ai-open-access w3-text-green"></i> <a href=http://dx.doi.org/10.1007/s00446-018-0342-6>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/1608.00214>arXiv preprint</a></li> <li class=list-inline-item> <a href=#lenzen16firing>Conference version</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=lenzen18firing-full> <p> Distributed Computing, volume 32, pages 339--360 (2019) &bull; <a href=http://dx.doi.org/10.1007/s00446-018-0342-6>doi:10.1007/s00446-018-0342-6</a> </p> <hr> <h6>Abstract</h6> <p>Consider a fully-connected synchronous distributed system consisting of n nodes, where up to f nodes may be faulty and every node starts in an arbitrary initial state. In the synchronous $C$-counting problem, all nodes need to eventually agree on a counter that is increased by one modulo $C$ in each round for given $C>1$. In the self-stabilising firing squad problem, the task is to eventually guarantee that all non-faulty nodes have simultaneous responses to external inputs: if a subset of the correct nodes receive an external “go” signal as input, then all correct nodes should agree on a round (in the not-too-distant future) in which to jointly output a “fire” signal. Moreover, no node should generate a “fire” signal without some correct node having previously received a “go” signal as input. We present a framework reducing both tasks to binary consensus at very small cost. For example, we obtain a deterministic algorithm for self-stabilising Byzantine firing squads with optimal resilience $f \lt n/3$, asymptotically optimal stabilisation and response time $O(f)$, and message size $O(\log f)$. As our framework does not restrict the type of consensus routines used, we also obtain efficient randomised solutions.</p> </div> </li></ul><h3 class=w3-opacity>2018</h3><ul class=publist><li id=rybicki18infective class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('rybicki18infective')">Model of bacterial toxin-dependent pathogenesis explains infective dose</a><br> <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a>, <a href=https://www.mv.helsinki.fi/home/kisdi/ class=authorurl>Eva Kisdi</a> and <a href=http://www.mv.helsinki.fi/jvanttil/ class=authorurl>Jani V. Anttila</a> &bull; <i> <a href=https://www.pnas.org/ class=authorurl> Proceedings of the National Academy of Sciences 2018 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <i class="ai ai-open-access w3-text-green"></i> <a href=http://dx.doi.org/10.1073/pnas.1721061115>Publisher&#x27;s version</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=rybicki18infective-full> <p> Proceedings of the National Academy of Sciences, (2018) &bull; <a href=http://dx.doi.org/10.1073/pnas.1721061115>doi:10.1073/pnas.1721061115</a> </p> <hr> <h6>Abstract</h6> <p>The initial amount of pathogens required to start an infection within a susceptible host is called the infective dose and is known to vary to a large extent between different pathogen species. We investigate the hypothesis that the differences in infective doses are explained by the mode of action in the underlying mechanism of pathogenesis: Pathogens with locally acting mechanisms tend to have smaller infective doses than pathogens with distantly acting mechanisms. While empirical evidence tends to support the hypothesis, a formal theoretical explanation has been lacking. We give simple analytical models to gain insight into this phenomenon and also investigate a stochastic, spatially explicit, mechanistic within-host model for toxin-dependent bacterial infections. The model shows that pathogens secreting locally acting toxins have smaller infective doses than pathogens secreting diffusive toxins, as hypothesized. While local pathogenetic mechanisms require smaller infective doses, pathogens with distantly acting toxins tend to spread faster and may cause more damage to the host. The proposed model can serve as a basis for the spatially explicit analysis of various virulence factors also in the context of other problems in infection dynamics.</p> </div> </li></ul><h3 class=w3-opacity>2017</h3><ul class=publist><li id=Hirvonen2017Cuts class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('Hirvonen2017Cuts')">Large cuts with local algorithms on triangle-free graphs</a><br> <a href=https://users.aalto.fi/~hirvonj7/ class=authorurl>Juho Hirvonen</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a>, <a href=https://schmiste.github.io/ class=authorurl>Stefan Schmid</a> and <a href=http://users.ics.aalto.fi/suomela/ class=authorurl>Jukka Suomela</a> &bull; <i> <a class=authorurl href=http://www.combinators.org> Electronic Journal of Combinatorics 2017 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <i class="ai ai-open-access w3-text-green"></i> <a href=http://www.combinatorics.org/ojs/index.php/eljc/article/view/v24i4p21>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/1402.2543>arXiv preprint</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=Hirvonen2017Cuts-full> <p> Electronic Journal of Combinatorics, volume 24, number 4, paper #P4.21 (2017) </p> <hr> <h6>Abstract</h6> <p>We study the problem of finding large cuts in $d$-regular triangle-free graphs. In prior work, Shearer (1992) gives a randomised algorithm that finds a cut of expected size $(1/2 + 0.177/\sqrt{d})m$, where $m$ is the number of edges. We give a simpler algorithm that does much better: it finds a cut of expected size $(1/2 + 0.28125/\sqrt{d})m$. As a corollary, this shows that in any $d$-regular triangle-free graph there exists a cut of at least this size. Our algorithm can be interpreted as a very efficient randomised distributed algorithm: each node needs to produce only one random bit, and the algorithm runs in one synchronous communication round. This work is also a case study of applying computational techniques in the design of distributed algorithms: our algorithm was designed by a computer program that searched for optimal algorithms for small values of $d$.</p> </div> </li><li id=lenzen2017counting class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('lenzen2017counting')">Efficient counting with optimal resilience</a><br> <a href=http://people.mpi-inf.mpg.de/~clenzen/ class=authorurl>Christoph Lenzen</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> and <a href=http://users.ics.aalto.fi/suomela/ class=authorurl>Jukka Suomela</a> &bull; <i> <a class=authorurl href=https://www.siam.org/journals/sicomp.php> SIAM Journal on Computing 2017 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1137/16M107877X>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/1508.02535>arXiv preprint</a></li> <li class=list-inline-item> <a href=#lenzen2015counting>Conference version</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=lenzen2017counting-full> <p> SIAM Journal on Computing, volume 46, number 4, pages 1473--1500 (2017) &bull; <a href=http://dx.doi.org/10.1137/16M107877X>doi:10.1137/16M107877X</a> </p> <hr> <h6>Abstract</h6> <p>Consider a complete communication network of $n$ nodes, where the nodes receive a common clock pulse. We study the synchronous $c$-counting problem: given any starting state and up to $f$ faulty nodes with arbitrary behavior, the task is to eventually have all correct nodes labeling the pulses with increasing values modulo $c$ in agreement. Thus, we are considering algorithms that are self-stabilizing despite Byzantine failures. In this work, we give new algorithms for the synchronous counting problem that (1) are deterministic, (2) have optimal resilience, (3) have a linear stabilization time in $f$ (asymptotically optimal), (4) use a small number of states, and, consequently, (5) communicate a small number of bits per round. Prior algorithms either resort to randomization, use a large number of states and need high communication bandwidth, or have suboptimal resilience. In particular, we achieve an exponential improvement in both state complexity and message size for deterministic algorithms. Moreover, we present two complementary approaches for reducing the number of bits communicated during and after stabilization.</p> </div> </li><li id=Korhonen2017Subgraph class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('Korhonen2017Subgraph')">Deterministic subgraph detection in broadcast CONGEST</a><br> <a href=https://pub.ist.ac.at/~jkorhone/ class=authorurl>Janne H. Korhonen</a> and <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> &bull; <i> <a href=http://opodis2017.campus.ciencias.ulisboa.pt/ class=authorurl> OPODIS 2017 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <i class="ai ai-open-access w3-text-green"></i> <a href=http://dx.doi.org/10.4230/LIPIcs.OPODIS.2017.4>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/1705.10195>arXiv preprint</a></li> <li class=list-inline-item><a href=./pdf/slides-opodis-2017.pdf>Janne&#x27;s OPODIS slides</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=Korhonen2017Subgraph-full> <p> 21st International Conference on Principles of Distributed Systems (2017) &bull; <a href=http://dx.doi.org/10.4230/LIPIcs.OPODIS.2017.4>doi:10.4230/LIPIcs.OPODIS.2017.4</a> </p> <hr> <h6>Abstract</h6> <p>We present simple deterministic algorithms for subgraph finding and enumeration in the broadcast CONGEST model of distributed computation:</p><ul><li> For any constant $k$, detecting $k$-paths and trees on $k$ nodes can be done in $O(1)$ rounds.</li> <li> For any constant $k$, detecting $k$-cycles and pseudotrees on $k$ nodes can be done in $O(n)$ rounds.</li><li> On $d$-degenerate graphs, cliques and $4$-cycles can be enumerated in $O(d + \log n)$ rounds, and $5$-cycles in $O(d^2 + \log n)$ rounds. </li></ul><p>In many cases, these bounds are tight up to logarithmic factors. Moreover, we show that the algorithms for $d$-degenerate graphs can be improved to optimal complexity $O(d/\log n)$ and $O(d^2/\log n)$, respectively, in the supported CONGEST model, which can be seen as an intermediate model between CONGEST and the congested clique.</p> <h6>Proceedings</h6> <p>Proceedings the 21st International Conference on Principles of Distributed Systems 18-20 December 2017, Lisboa, Portugal, pages 4:1--4:16, 2017 </p> </div> </li><li id=lenzen2017pulse class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('lenzen2017pulse')">Self-stabilising pulse synchronisation is almost as easy as consensus</a><br> <a href=http://people.mpi-inf.mpg.de/~clenzen/ class=authorurl>Christoph Lenzen</a> and <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> &bull; <i> <a href=http://www.disc-conference.org/wp/disc2017/ class=authorurl> DISC 2017 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <i class="ai ai-open-access w3-text-green"></i> <a href=http://dx.doi.org/10.4230/LIPIcs.DISC.2017.32>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/1705.06173>arXiv preprint</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=lenzen2017pulse-full> <p> 31st International Symposium on Distributed Computing (2017) &bull; <a href=http://dx.doi.org/10.4230/LIPIcs.DISC.2017.32>doi:10.4230/LIPIcs.DISC.2017.32</a> </p> <hr> <h6>Abstract</h6> <p>We give fault-tolerant algorithms for establishing synchrony in distributed systems in which each of the n nodes has its own clock. Our algorithms operate in a very strong fault model: we require self-stabilisation, i.e., the initial state of the system may be arbitrary, and there can be up to $f \lt n/3$ ongoing Byzantine faults, i.e., nodes that deviate from the protocol in an arbitrary manner. Furthermore, we assume that the local clocks of the nodes may progress at different speeds (clock drift) and communication has bounded delay. In this model, we study the pulse synchronisation problem, where the task is to guarantee that eventually all correct nodes generate well-separated local pulse events (i.e., unlabelled logical clock ticks) in a synchronised manner. Compared to prior work, we achieve exponential improvements in stabilisation time and the number of communicated bits, and give the first sublinear-time algorithm for the problem:</p><ul><li>In the deterministic setting, the state-of-the-art solutions stabilise in time $\Theta(f)$ and have each node broadcast $\Theta(f \log f)$ bits per time unit. We exponentially reduce the number of bits broadcasted per time unit to $\Theta(\log f)$ while retaining the same stabilisation time.</li><li>In the randomised setting, the state-of-the-art solutions stabilise in time $\Theta(f)$ and have each node broadcast $O(1)$ bits per time unit. We exponentially reduce the stabilisation time to polylog $f$ while each node broadcasts polylog $f$ bits per time unit.</ul><p>These results are obtained by means of a recursive approach reducing the above task of self-stabilising pulse synchronisation in the bounded-delay model to non-self-stabilising binary consensus in the synchronous model. In general, our approach introduces at most logarithmic overheads in terms of stabilisation time and broadcasted bits over the underlying consensus routine.</p> </div> </li><li id=Brandt2017 class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('Brandt2017')">LCL problems on grids</a><br> <a class=authorurl href=http://www.disco.ethz.ch/members/brandts.html>Sebastian Brandt</a>, <a href=https://users.aalto.fi/~hirvonj7/ class=authorurl>Juho Hirvonen</a>, <a href=https://pub.ist.ac.at/~jkorhone/ class=authorurl>Janne H. Korhonen</a>, <a href=http://users.aalto.fi/~tuomolem/ class=authorurl>Tuomo Lempiäinen</a>, <a href=https://users.aalto.fi/~pat/ class=authorurl>Patric R.J. Östergård</a>, Christopher Purcell, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a>, <a href=http://users.ics.aalto.fi/suomela/ class=authorurl>Jukka Suomela</a> and Przemysław Uznański &bull; <i> <a href=https://www.podc.org/podc2017/ class=authorurl> PODC 2017 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1145/3087801.3087833>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/1702.05456>arXiv preprint</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=Brandt2017-full> <p> ACM Symposium on Principles of Distributed Computing (2017) &bull; <a href=http://dx.doi.org/10.1145/3087801.3087833>doi:10.1145/3087801.3087833</a> </p> <hr> <h6>Abstract</h6> <p>LCLs or locally checkable labelling problems (e.g. maximal independent set, maximal matching, and vertex colouring) in the LOCAL model of computation are very well-understood in cycles (toroidal 1-dimensional grids): every problem has a complexity of $O(1)$, $\Theta(\log^* n)$, or $\Theta(n)$, and the design of optimal algorithms can be fully automated. This work develops the complexity theory of LCL problems for toroidal 2-dimensional grids. The complexity classes are the same as in the 1-dimensional case: $O(1)$, $\Theta(\log^* n)$, and $\Theta(n)$. However, given an LCL problem it is undecidable whether its complexity is $\Theta(\log^* n)$ or $\Theta(n)$ in 2-dimensional grids. Nevertheless, if we correctly guess that the complexity of a problem is $\Theta(\log^* n)$, we can completely automate the design of optimal algorithms. For any problem we can find an algorithm that is of a normal form $A' \circ S_k$, where $A'$ is a finite function, $S_k$ is an algorithm for finding a maximal independent set in $k$th power of the grid, and $k$ is a constant. Finally, partially with the help of automated design tools, we classify the complexity of several concrete LCL problems related to colourings and orientations.</p> <h6>Proceedings</h6> <p>Proceedings of the ACM Symposium on Principles of Distributed Computing - PODC &#x27;17, pages 101--110, 2017 </p> </div> </li></ul><h3 class=w3-opacity>2016</h3><ul class=publist><li id=hasemann16scheduling class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('hasemann16scheduling')">Deterministic local algorithms, unique identifiers, and fractional graph colouring</a><br> <a href=http://www.ibr.cs.tu-bs.de/users/hasemann/ class=authorurl>Henning Hasemann</a>, <a href=https://users.aalto.fi/~hirvonj7/ class=authorurl>Juho Hirvonen</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> and <a href=http://users.ics.aalto.fi/suomela/ class=authorurl>Jukka Suomela</a> &bull; <i> <a href=https://www.journals.elsevier.com/theoretical-computer-science/ class=authorurl> Theoretical Computer Science 2016 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1016/j.tcs.2014.06.044>Publisher&#x27;s version</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=hasemann16scheduling-full> <p> Theoretical Computer Science, volume 610, pages 204--217 (2016) &bull; <a href=http://dx.doi.org/10.1016/j.tcs.2014.06.044>doi:10.1016/j.tcs.2014.06.044</a> </p> <hr> <h6>Abstract</h6> <p>We show that for any $\alpha > 1$ there exists a deterministic distributed algorithm that finds a fractional graph colouring of length at most $\alpha (\Delta + 1)$ in any graph in one synchronous communication round; here $\Delta$ is the maximum degree of the graph. The result is near-tight, as there are graphs in which the optimal solution has length $\Delta+1$. The result is, of course, too good to be true. The usual definitions of scheduling problems (fractional graph colouring, fractional domatic partition, etc.) in a distributed setting leave a loophole that can be exploited in the design of distributed algorithms: the size of the local output is not bounded. Our algorithm produces an output that seems to be perfectly good by the usual standards but it is impractical, as the schedule of each node consists of a very large number of short periods of activity. More generally, the algorithm shows that when we study distributed algorithms for scheduling problems, we can choose virtually any trade-off between the following three parameters: $T$, the running time of the algorithm, $\ell$, the length of the schedule, and $\kappa$, the maximum number of periods of activity for a any single node. Here $\ell$ is the objective function of the optimisation problem, while $\kappa$ captures the “subjective” quality of the solution. If we study, for example, bounded-degree graphs, we can trivially keep $T$ and $\kappa$ constant, at the cost of a large $\ell$, or we can keep $\kappa$ and $\ell$ constant, at the cost of a large $T$. Our algorithm shows that yet another trade-off is possible: we can keep $T$ and $\ell$ constant at the cost of a large $\kappa$.</p> </div> </li><li id=dolev16synthesis class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('dolev16synthesis')">Synchronous counting and computational algorithm design</a><br> <a href=http://www.cs.huji.ac.il/~dolev/ class=authorurl>Danny Dolev</a>, <a href=https://users.ics.aalto.fi/kepa/ class=authorurl>Keijo Heljanko</a>, <a href=http://www.cs.helsinki.fi/u/mjarvisa/ class=authorurl>Matti Järvisalo</a>, <a href=https://pub.ist.ac.at/~jkorhone/ class=authorurl>Janne H. Korhonen</a>, <a href=http://people.mpi-inf.mpg.de/~clenzen/ class=authorurl>Christoph Lenzen</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a>, <a href=http://users.ics.aalto.fi/suomela/ class=authorurl>Jukka Suomela</a> and <a href=http://www.siert.nl/ class=authorurl>Siert Wieringa</a> &bull; <i> <a class=authorurl href=https://www.journals.elsevier.com/journal-of-computer-and-system-sciences> Journal of Computer and System Sciences 2016 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1016/j.jcss.2015.09.002>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/1304.5719v1>arXiv preprint</a></li> <li class=list-inline-item> <a href=#dolev13counting>Conference version</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=dolev16synthesis-full> <p> Journal of Computer and System Sciences, volume 82, number 2, pages 310--332 (2016) &bull; <a href=http://dx.doi.org/10.1016/j.jcss.2015.09.002>doi:10.1016/j.jcss.2015.09.002</a> </p> <hr> <h6>Abstract</h6> <p>Consider a complete communication network on $n$ nodes. In synchronous 2-counting, the nodes receive a common clock pulse and they have to agree on which pulses are "odd" and which are "even". Furthermore, the solution needs to be self-stabilising (reaching correct operation from any initial state) and tolerate $f$ Byzantine failures (nodes that send arbitrary misinformation). Prior algorithms either require a source of random bits or a large number of states per node. In this work, we give fast state-optimal deterministic algorithms for the first non-trivial case $f=1$. To obtain these algorithms, we develop and evaluate two different techniques for algorithm synthesis. Both are based on casting the synthesis problem as a propositional satisfiability (SAT) problem; a direct encoding is efficient for synthesising time-optimal algorithms, while an approach based on counter-example guided abstraction refinement discovers non-optimal algorithms quickly.</p> </div> </li><li id=lenzen16firing class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('lenzen16firing')">Near-optimal self-stabilising counting and firing squads</a><br> <a href=http://people.mpi-inf.mpg.de/~clenzen/ class=authorurl>Christoph Lenzen</a> and <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> &bull; <i> <a class=authorurl href=http://www.selfstabilization.org/~selfstab/sss2016> SSS 2016 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1007/978-3-319-49259-9_21>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/1608.00214>arXiv preprint</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=lenzen16firing-full> <p> 18th International Symposium on Stabilization, Safety, and Security of Distributed Systems (2016) &bull; <a href=http://dx.doi.org/10.1007/978-3-319-49259-9_21>doi:10.1007/978-3-319-49259-9_21</a> </p> <hr> <h6>Abstract</h6> <p>Consider a fully-connected synchronous distributed system of $n$ nodes, where up to $f$ nodes may be faulty and every node starts in an arbitrary initial state. In the <em>synchronous counting</em> problem, all nodes need to eventually agree on a counter that is increased by one modulo some $C$ in each round. In the <em>self-stabilising firing squad</em> problem, the task is to eventually guarantee that all non-faulty nodes have simultaneous responses to external inputs: if a subset of the correct nodes receive an external 'go' signal as input, then all correct nodes should agree on a round (in the not-too-distant future) in which to jointly output a 'fire' signal. Moreover, no node should generate a 'fire' signal without some correct node having previously received a ``go'' signal as input. We present a framework reducing both tasks to binary consensus at very small cost: we maintain the resilience of the underlying consensus routine, while the stabilisation time and message size are, up to constant factors, bounded by the sum of the cost of the consensus routine for $f$ faults and recursively applying our scheme to $f' \lt f/2$ faults. For example, we obtain a deterministic algorithm for self-stabilising Byzantine firing squads with optimal resilience $f \lt n/3$, asymptotically optimal stabilisation and response time $O(f)$, and message size $O(\log f)$. As our framework does not restrict the type of consensus routines used, we also obtain efficient randomised solutions, and it is straightforward to adapt our framework to allow for $f \lt n/2$ omission or $f \lt n$ crash faults. Our results resolve various open questions on the two problems, most prominently whether (communication-efficient) self-stabilising Byzantine firing squads or sublinear-time solutions for either problem exist.</p> <h6>Proceedings</h6> <p>Proceedings of the 18th International Symposium on Stabilization, Safety, and Security of Distributed Systems (SSS 2016), volume 10083 of Lecture Notes in Computer Science, pages 263--280, 2016 </p> </div> </li><li id=Brandt2016 class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('Brandt2016')">A lower bound for the distributed Lovász local lemma</a><br> <a class=authorurl href=http://www.disco.ethz.ch/members/brandts.html>Sebastian Brandt</a>, Orr Fischer, <a href=https://users.aalto.fi/~hirvonj7/ class=authorurl>Juho Hirvonen</a>, <a href=https://users.aalto.fi/~kellerb1/ class=authorurl>Barbara Keller</a>, <a href=http://users.aalto.fi/~tuomolem/ class=authorurl>Tuomo Lempiäinen</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a>, <a href=http://users.ics.aalto.fi/suomela/ class=authorurl>Jukka Suomela</a> and <a href=https://users.aalto.fi/~uittoj3/ class=authorurl>Jara Uitto</a> &bull; <i> <a href=http://acm-stoc.org/stoc2016/ class=authorurl> STOC 2016 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1145/2897518.2897570>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/1511.00900>arXiv preprint</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=Brandt2016-full> <p> 48th Annual ACM SIGACT Symposium on Theory of Computing (2016) &bull; <a href=http://dx.doi.org/10.1145/2897518.2897570>doi:10.1145/2897518.2897570</a> </p> <hr> <h6>Abstract</h6> <p>We show that any randomised Monte Carlo distributed algorithm for the Lovász local lemma requires $\Omega(\log \log n)$ communication rounds, assuming that it finds a correct assignment with high probability. Our result holds even in the special case of $d = O(1)$, where d is the maximum degree of the dependency graph. By prior work, there are distributed algorithms for the Lovász local lemma with a running time of $O(\log n)$ rounds in bounded-degree graphs, and the best lower bound before our work was $\Omega(\log^* n)$ rounds [Chung et al. 2014].</p> <h6>Proceedings</h6> <p>Proceedings of the 48th Annual ACM SIGACT Symposium on Theory of Computing - STOC 2016, pages 479--488, 2016 </p> </div> </li></ul><h3 class=w3-opacity>2015</h3><ul class=publist><li id=Ramiadantsoa2015 class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('Ramiadantsoa2015')">Large-scale habitat corridors for biodiversity conservation: A forest corridor in Madagascar</a><br> <a href=https://ramiadantsoa.github.io/ class=authorurl>Tanjona Ramiadantsoa</a>, <a class=authorurl href=http://www.helsinki.fi/science/metapop/People/Otso.htm>Otso Ovaskainen</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> and Ilkka Hanski &bull; <i> <a href=http://journals.plos.org/plosone/ class=authorurl> PLOS ONE 2015 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <i class="ai ai-open-access w3-text-green"></i> <a href=http://dx.doi.org/10.1371/journal.pone.0132126>Publisher&#x27;s version</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=Ramiadantsoa2015-full> <p> PLOS ONE, volume 10, number 7, paper e0132126 (2015) &bull; <a href=http://dx.doi.org/10.1371/journal.pone.0132126>doi:10.1371/journal.pone.0132126</a> </p> <hr> <h6>Abstract</h6> <p>In biodiversity conservation, habitat corridors are assumed to increase landscape-level connectivity and to enhance the viability of otherwise isolated populations. While the role of corridors is supported by empirical evidence, studies have typically been conducted at small spatial scales. Here, we assess the quality and the functionality of a large 95-km long forest corridor connecting two large national parks (416 and 311 km&#178;) in the southeastern escarpment of Madagascar. We analyze the occurrence of 300 species in 5 taxonomic groups in the parks and in the corridor, and combine high-resolution forest cover data with a simulation model to examine various scenarios of corridor destruction. At present, the corridor contains essentially the same communities as the national parks, reflecting its breadth which on average matches that of the parks. In the simulation model, we consider three types of dispersers: passive dispersers, which settle randomly around the source population; active dispersers, which settle only in favorable habitat; and gap-avoiding active dispersers, which avoid dispersing across non-habitat. Our results suggest that long-distance passive dispersers are most sensitive to ongoing degradation of the corridor, because increasing numbers of propagules are lost outside the forest habitat. For a wide range of dispersal parameters, the national parks are large enough to sustain stable populations until the corridor becomes severely broken, which will happen around 2065 if the current rate of forest loss continues. A significant decrease in gene flow along the corridor is expected after 2040, and this will exacerbate the adverse consequences of isolation. Our results demonstrate that simulation studies assessing the role of habitat corridors should pay close attention to the mode of dispersal and the effects of regional stochasticity.</p> </div> </li><li id=lenzen2015counting class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('lenzen2015counting')">Efficient counting with optimal resilience</a><br> <a href=http://people.mpi-inf.mpg.de/~clenzen/ class=authorurl>Christoph Lenzen</a> and <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> &bull; <i> <a href=http://www.disc-conference.org/wp/wp/disc2015/ class=authorurl> DISC 2015 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1007/978-3-662-48653-5_2>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/1508.02535>arXiv preprint</a></li> <li class=list-inline-item> <a href=#lenzen2017counting>Journal version</a></li> <li class=list-inline-item><a href=./pdf/disc-counting-2015-10-07.pdf>DISC slides</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=lenzen2015counting-full> <p> 29th International Symposium on Distributed Computing (DISC 2015) (2015) &bull; <a href=http://dx.doi.org/10.1007/978-3-662-48653-5_2>doi:10.1007/978-3-662-48653-5_2</a> </p> <hr> <h6>Abstract</h6> <p>In the synchronous $c$-counting problem, we are given a synchronous system of $n$ nodes, where up to $f$ of the nodes may be Byzantine, that is, have arbitrary faulty behaviour. The task is to have all of the correct nodes count modulo $c$ in unison in a self-stabilising manner: regardless of the initial state of the system and the faulty nodes’ behavior, eventually rounds are consistently labelled by a counter modulo c at all correct nodes. We provide a deterministic solution with resilience $f \lt n/3$ that stabilises in $O(f)$ rounds and every correct node broadcasts $O(\log^2 f)$ bits per round. We build and improve on a recent result offering stabilisation time $O(f)$ and communication complexity $O(\log^2 f/ \log \log f)$ but with sub-optimal resilience $f=n^{1−o(1)}$ (PODC 2015). Our new algorithm has optimal resilience, asymptotically optimal stabilisation time, and low communication complexity. Finally, we modify the algorithm to guarantee that after stabilisation very little communication occurs. In particular, for optimal resilience and polynomial counter size $c=n^{O(1)}$, the algorithm broadcasts only $O(1)$ bits per node every $\Theta(n)$ rounds without affecting the other properties of the algorithm; communication-wise this is asymptotically optimal.</p> <h6>Proceedings</h6> <p>Proceedings of the 29th International Symposium on Distributed Computing (DISC 2015), Tokyo, Japan, October 7--13, 2015, volume 9363 of Lecture Notes in Computer Science, pages 16--30, 2015 </p> </div> </li><li id=rybicki2015exact class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('rybicki2015exact')">Exact bounds for distributed graph colouring</a><br> <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> and <a href=http://users.ics.aalto.fi/suomela/ class=authorurl>Jukka Suomela</a> &bull; <i> <a href=http://sirocco2015.cs.upb.de/ class=authorurl> SIROCCO 2015 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1007/978-3-319-25258-2_4>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/1502.04963>arXiv preprint</a></li> <li class=list-inline-item><a href=./pdf/sirocco2015-colouring.pdf>SIROCCO slides</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=rybicki2015exact-full> <p> 22nd International Colloquium on Structural Information and Communication Complexity (2015) &bull; <a href=http://dx.doi.org/10.1007/978-3-319-25258-2_4>doi:10.1007/978-3-319-25258-2_4</a> </p> <hr> <h6>Abstract</h6> <p>We prove exact bounds on the time complexity of distributed graph colouring. If we are given a directed path that is properly coloured with n colours, by prior work it is known that we can find a proper 3-colouring in $\log^*(n) \pm O(1)$ communication rounds. We close the gap between upper and lower bounds: we show that for infinitely many n the time complexity is precisely $\log^* n$ communication rounds.</p> <h6>Proceedings</h6> <p>Structural Information and Communication Complexity: Post-proceedings of the 22nd International Colloquium (SIROCCO 2015), volume 9439 of Lecture Notes in Computer Science, pages 46--60, 2015 </p> </div> </li><li id=lenzen2015towards class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('lenzen2015towards')">Towards optimal synchronous counting</a><br> <a href=http://people.mpi-inf.mpg.de/~clenzen/ class=authorurl>Christoph Lenzen</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> and <a href=http://users.ics.aalto.fi/suomela/ class=authorurl>Jukka Suomela</a> &bull; <i> <a href=https://www.podc.org/podc2015/ class=authorurl> PODC 2015 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1145/2767386.2767423>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/1503.06702v1>arXiv preprint</a></li> <li class=list-inline-item> <a href=#lenzen2017counting>Journal version</a></li> <li class=list-inline-item><a href=./pdf/podc2015-slides.pdf>PODC slides</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=lenzen2015towards-full> <p> 34th ACM Symposium on Principles of Distributed Computing (2015) &bull; <a href=http://dx.doi.org/10.1145/2767386.2767423>doi:10.1145/2767386.2767423</a> </p> <hr> <h6>Abstract</h6> <p>Consider a complete communication network of n nodes, in which the nodes receive a common clock pulse. We study the synchronous c-counting problem: given any starting state and up to f faulty nodes with arbitrary behaviour, the task is to eventually have all correct nodes count modulo c in agreement. Thus, we are considering algorithms that are self-stabilising despite Byzantine failures. In this work, we give new algorithms for the synchronous counting problem that (1) are deterministic, (2) have linear stabilisation time in f, (3) use a small number of states, and (4) achieve almost-optimal resilience. Prior algorithms either resort to randomisation, use a large number of states, or have poor resilience. In particular, we achieve an exponential improvement in the state complexity of deterministic algorithms, while still achieving linear stabilisation time and almost-linear resilience.</p> <h6>Proceedings</h6> <p>Proceedings of the 34th ACM Symposium on Principles of Distributed Computing (PODC 2015), pages 441--450, 2015 </p> </div> </li></ul><h3 class=w3-opacity>2013</h3><ul class=publist><li id=Rybicki2013SAR class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('Rybicki2013SAR')">Species-area relationships and extinctions caused by habitat loss and fragmentation</a><br> <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> and Ilkka Hanski &bull; <i> <a class=authorurl href=http://onlinelibrary.wiley.com/journal/10.1111/(ISSN)1461-0248> Ecology Letters 2013 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1111/ele.12065>Publisher&#x27;s version</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=Rybicki2013SAR-full> <p> Ecology Letters, volume 16, number S1, pages 27--38 (2013) &bull; <a href=http://dx.doi.org/10.1111/ele.12065>doi:10.1111/ele.12065</a> </p> <hr> <h6>Abstract</h6> <p>The species–area relationship (SAR) has been used to predict the numbers of species going extinct due to habitat loss, but other researchers have maintained that SARs overestimate extinctions and instead one should use the endemics–area relationship (EAR) to predict extinctions. Here, we employ spatially explicit simulations of large numbers of species in spatially heterogeneous landscapes to investigate SARs and extinctions in a dynamic context. The EAR gives the number of species going extinct immediately after habitat loss, but typically many other species have unviable populations in the remaining habitat and go extinct soon afterwards. We conclude that the EAR underestimates extinctions due to habitat loss, the continental SAR (with slope ~0.1 or somewhat less) gives a good approximation of short-term extinctions, while the island SAR calculated for discrete fragments of habitat (with slope ~0.25) predicts the long-term extinctions. However, when the remaining area of land-covering habitat such as forest is roughly less than 20% of the total landscape and the habitat is highly fragmented, all current SARs underestimate extinction rate. We show how the ‘fragmentation effect’ can be incorporated into a predictive SAR model. When the remaining habitat is highly fragmented, an effective way to combat the fragmentation effect is to aggregate habitat fragments into clusters rather than to place them randomly across the landscape.</p> <hr> <h6>Additional material</h6> <ul class=w3-margin> <li><a href=./pdf/rybicki2013sar-supplementary.pdf>Updated Supplementary information</a></li> <li><a href=./files/habitat-gen.tar.gz>Example implementation of the habitat generation algorithm</a></li> </ul> </div> </li><li id=Hanski2013SFAR class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('Hanski2013SFAR')">Species-fragmented area relationship</a><br> Ilkka Hanski, Gustavo A. Zurita, M. Isabel Bellocq and <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> &bull; <i> <a class=authorurl href=http://www.pnas.org> Proceedings of the National Academy of Sciences 2013 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <i class="ai ai-open-access w3-text-green"></i> <a href=http://dx.doi.org/10.1073/pnas.1311491110>Publisher&#x27;s version</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=Hanski2013SFAR-full> <p> Proceedings of the National Academy of Sciences, volume 110, number 31, pages 12715--12720 (2013) &bull; <a href=http://dx.doi.org/10.1073/pnas.1311491110>doi:10.1073/pnas.1311491110</a> </p> <hr> <h6>Abstract</h6> <p>The species-area relationship (SAR) gives a quantitative description of the increasing number of species in a community with increasing area of habitat. In conservation, SARs have been used to predict the number of extinctions when the area of habitat is reduced. Such predictions are most needed for landscapes rather than for individual habitat fragments, but SAR-based predictions of extinctions for landscapes with highly fragmented habitat are likely to be biased because SAR assumes contiguous habitat. In reality, habitat loss is typically accompanied by habitat fragmentation. To quantify the effect of fragmentation in addition to the effect of habitat loss on the number of species, we extend the power-law SAR to the species-fragmented area relationship. This model unites the single-species metapopulation theory with the multispecies SAR for communities. We demonstrate with a realistic simulation model and with empirical data for forest-inhabiting subtropical birds that the species-fragmented area relationship gives a far superior prediction than SAR of the number of species in fragmented landscapes. The results demonstrate that for communities of species that are not well adapted to live in fragmented landscapes, the conventional SAR underestimates the number of extinctions for landscapes in which little habitat remains and it is highly fragmented.</p> </div> </li><li id=dolev13counting class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('dolev13counting')">Synchronous counting and computational algorithm design</a><br> <a href=http://www.cs.huji.ac.il/~dolev/ class=authorurl>Danny Dolev</a>, <a href=https://pub.ist.ac.at/~jkorhone/ class=authorurl>Janne H. Korhonen</a>, <a href=http://people.mpi-inf.mpg.de/~clenzen/ class=authorurl>Christoph Lenzen</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> and <a href=http://users.ics.aalto.fi/suomela/ class=authorurl>Jukka Suomela</a> &bull; <i> <a class=authorurl href=http://www.selfstabilization.org/~selfstab/sss2013> SSS 2013 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1007/978-3-319-03089-0_17>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=http://arxiv.org/abs/1304.5719v1>arXiv preprint</a></li> <li class=list-inline-item> <a href=#dolev16synthesis>Journal version</a></li> <li class=list-inline-item><a href=./pdf/sss2013-presentation.pdf>SSS slides</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=dolev13counting-full> <p> 15th International Symposium on Stabilization, Safety, and Security of Distributed Systems (2013) &bull; <a href=http://dx.doi.org/10.1007/978-3-319-03089-0_17>doi:10.1007/978-3-319-03089-0_17</a> </p> <hr> <h6>Abstract</h6> <p>Consider a complete communication network on n nodes, each of which is a state machine with s states. In synchronous 2-counting, the nodes receive a common clock pulse and they have to agree on which pulses are 'odd' and which are 'even'. We require that the solution is self-stabilising (reaching the correct operation from any initial state) and it tolerates f Byzantine failures (nodes that send arbitrary misinformation). Prior algorithms are expensive to implement in hardware: they require a source of random bits or a large number of states $s$. We use computational techniques to construct very compact deterministic algorithms for the first non-trivial case of $f = 1$. While no algorithm exists for $n \lt 4$, we show that as few as 3 states are sufficient for all values $n \ge 4$. We prove that the problem cannot be solved with only 2 states for $n = 4$, but there is a 2-state solution for all values $n \ge 6$.</p> <h6>Proceedings</h6> <p>Proceedings of the 15th International Symposium on Stabilization, Safety, and Security of Distributed Systems (SSS 2013), volume 8255 of Lecture Notes in Computer Science, pages 237--250, 2013 </p> </div> </li></ul><h3 class=w3-opacity>2012</h3><ul class=publist><li id=hasemann12scheduling class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('hasemann12scheduling')">Deterministic local algorithms, unique identifiers, and fractional graph colouring</a><br> <a href=http://www.ibr.cs.tu-bs.de/users/hasemann/ class=authorurl>Henning Hasemann</a>, <a href=https://users.aalto.fi/~hirvonj7/ class=authorurl>Juho Hirvonen</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> and <a href=http://users.ics.aalto.fi/suomela/ class=authorurl>Jukka Suomela</a> &bull; <i> <a href=https://sites.google.com/site/sirocco2012iceland/ class=authorurl> SIROCCO 2012 </a> </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1007/978-3-642-31104-8_5>Publisher&#x27;s version</a></li> <li class=list-inline-item> <a href=#hasemann16scheduling>Journal version</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=hasemann12scheduling-full> <p> 19th International Colloquium on Structural Information and Communication Complexity (2012) &bull; <a href=http://dx.doi.org/10.1007/978-3-642-31104-8_5>doi:10.1007/978-3-642-31104-8_5</a> </p> <hr> <h6>Abstract</h6> <p>We show that for any $\alpha > 1$ there exists a deterministic distributed algorithm that finds a fractional graph colouring of length at most $\alpha (\Delta + 1)$ in any graph in one synchronous communication round; here $\Delta$ is the maximum degree of the graph. The result is near-tight, as there are graphs in which the optimal solution has length $\Delta+1$. The result is, of course, too good to be true. The usual definitions of scheduling problems (fractional graph colouring, fractional domatic partition, etc.) in a distributed setting leave a loophole that can be exploited in the design of distributed algorithms: the size of the local output is not bounded. Our algorithm produces an output that seems to be perfectly good by the usual standards but it is impractical, as the schedule of each node consists of a very large number of short periods of activity. More generally, the algorithm shows that when we study distributed algorithms for scheduling problems, we can choose virtually any trade-off between the following three parameters: $T$, the running time of the algorithm, $\ell$, the length of the schedule, and $\kappa$, the maximum number of periods of activity for a any single node. Here $\ell$ is the objective function of the optimisation problem, while $\kappa$ captures the “subjective” quality of the solution. If we study, for example, bounded-degree graphs, we can trivially keep $T$ and $\kappa$ constant, at the cost of a large $\ell$, or we can keep $\kappa$ and $\ell$ constant, at the cost of a large $T$. Our algorithm shows that yet another trade-off is possible: we can keep $T$ and $\ell$ constant at the cost of a large $\kappa$.</p> <h6>Proceedings</h6> <p>Proceedings of the 19th International Colloquium on Structural Information and Communication Complexity (SIROCCO 2012), volume 7355 of Lecture Notes in Computer Science, pages 48--60, 2012 </p> </div> </li></ul><h3 class=w3-opacity>2009</h3><ul class=publist><li id=astrand2009vc2apx class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('astrand2009vc2apx')">A local 2-approximation algorithm for the vertex cover problem</a><br> Matti Åstrand, <a href=http://www.cs.helsinki.fi/patrik.floreen/ class=authorurl>Patrik Floréen</a>, <a href=http://weber.itn.liu.se/~valpo40/ class=authorurl>Valentin Polishchuk</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a>, <a href=http://users.ics.aalto.fi/suomela/ class=authorurl>Jukka Suomela</a> and <a href=https://users.aalto.fi/~uittoj3/ class=authorurl>Jara Uitto</a> &bull; <i> DISC 2009 </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://dx.doi.org/10.1007/978-3-642-04355-0_21>Publisher&#x27;s version</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=astrand2009vc2apx-full> <p> 23rd International Symposium on Distributed Computing (2009) &bull; <a href=http://dx.doi.org/10.1007/978-3-642-04355-0_21>doi:10.1007/978-3-642-04355-0_21</a> </p> <hr> <h6>Abstract</h6> <p>We present a distributed 2-approximation algorithm for the minimum vertex cover problem. The algorithm is deterministic, and it runs in $(\Delta+1)^2$ synchronous communication rounds, where $\Delta$ is the maximum degree of the graph. For $\Delta=3$, we give a 2-approximation algorithm also for the weighted version of the problem.</p> <h6>Proceedings</h6> <p>Proceedings of the 23rd International Symposium on Distributed Computing (DISC 2009), volume 5805 of Lecture Notes in Computer Science, pages 191--205, 2009 </p> </div> </li></ul><h3 class=w3-opacity>Manuscripts</h3><ul class=publist><li id=andaur2021reaching class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('andaur2021reaching')">Reaching agreement in competitive microbial systems</a><br> Victoria Andaur, Janna Burman, <a href=http://www.lsv.fr/~mfuegger/ class=authorurl>Matthias Függer</a>, Manish Kushwaha, Bilal Manssouri, <a href=https://www.lri.fr/~nowak/ class=authorurl>Thomas Nowak</a> and <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a> &bull; <i> Manuscript. </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href="http://arxiv.org/abs/2103.07450 ">arXiv preprint</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=andaur2021reaching-full> <p> Manuscript (2021) </p> <hr> <h6>Abstract</h6> <p>In this work, we consider distributed agreement tasks in microbial distributed systems under stochastic population dynamics and competitive interactions. We examine how competitive exclusion can be used to solve distributed agreement tasks in the microbial setting. To this end, we develop a new technique for analyzing the time to reach competitive exclusion in systems with two competing species under biologically realistic population dynamics. We use this technique to analyze a protocol that exploits competitive interactions to solve approximate majority consensus efficiently in microbial systems. To corroborate our analytical results, we use computer simulations to show that these consensus dynamics occur within practical time scales.</p> </div> </li><li id=astrand2010weakly class=li-pub-closed><a class="papertitle w3-opacity w3-large" onclick="myFunction('astrand2010weakly')">Local algorithms in (weakly) coloured graphs</a><br> Matti Åstrand, <a href=http://weber.itn.liu.se/~valpo40/ class=authorurl>Valentin Polishchuk</a>, <a href=https://pub.ist.ac.at/~jrybicki/ class=authorurl>Joel Rybicki</a>, <a href=http://users.ics.aalto.fi/suomela/ class=authorurl>Jukka Suomela</a> and <a href=https://users.aalto.fi/~uittoj3/ class=authorurl>Jara Uitto</a> &bull; <i> Manuscript. </i> <br> <ul class="list-inline list-middot w3-opacity"> <li class=list-inline-item> <a href=http://arxiv.org/abs/1002.0125>arXiv preprint</a></li> </ul> <div class="w3-card w3-container w3-hide w3-margin-top w3-margin-bottom" id=astrand2010weakly-full> <p> Manuscript (2010) </p> <hr> <h6>Abstract</h6> <p>A local algorithm is a distributed algorithm that completes after a constant number of synchronous communication rounds. We present local approximation algorithms for the minimum dominating set problem and the maximum matching problem in 2-coloured and weakly 2-coloured graphs. In a weakly 2-coloured graph, both problems admit a local algorithm with the approximation factor $(\Delta+1)/2$, where $\Delta$ is the maximum degree of the graph. We also give a matching lower bound proving that there is no local algorithm with a better approximation factor for either of these problems. Furthermore, we show that the stronger assumption of a 2-colouring does not help in the case of the dominating set problem, but there is a local approximation scheme for the maximum matching problem in 2-coloured graphs.</p> </div> </li></ul></div> </div> <div class="w3-right-align w3-margin-right">Last updated: May 29, 2024 </div> </div> </div></div><footer class="page-footer w3-container w3-green w3-center w3-margin-top"></footer></body></html>